<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/png">
    <title>参加コンテストログ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 0 10px; color: #333; }
        h1 { border-bottom: 2px solid #ddd; padding-bottom: 10px; }
        
        /* グラフ用コンテナ */
        .chart-container { position: relative; height: 300px; width: 100%; margin-bottom: 40px; }

        /* テーブルのデザイン */
        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f4f4f4; white-space: nowrap; }
        tr:hover { background-color: #f9f9f9; }

        /* パフォーマンスの色定義 */
        .perf-gray { color: #808080; font-weight: bold; }
        .perf-brown { color: #804000; font-weight: bold; }
        .perf-green { color: #008000; font-weight: bold; }
        .perf-cyan { color: #00C0C0; font-weight: bold; }
        .perf-blue { color: #0000FF; font-weight: bold; }
        .perf-yellow { color: #C0C000; font-weight: bold; }
        .perf-orange { color: #FF8000; font-weight: bold; }
        .perf-red { color: #FF0000; font-weight: bold; }

        .details { font-family: Consolas, monospace; font-size: 0.9em; color: #555; }
        
        /* フッター */
        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        footer a {
            text-decoration: none;
            color: #555;
            font-size: 14px;
        }
        footer a:hover {
            color: #000;
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            th, td { display: block; width: 100%; box-sizing: border-box; }
            th { display: none; }
            td { border: none; padding: 5px 10px; }
            tr { border-bottom: 1px solid #ccc; display: block; margin-bottom: 10px; padding-bottom: 10px; }
            .date-cell { color: #888; font-size: 0.8em; }
            .chart-container { height: 400px; }
        }
    </style>
</head>
<body>

    <h1>Contest Log</h1>
    
    <div class="chart-container">
        <canvas id="timelineChart"></canvas>
    </div>

    <table id="log-table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Contest</th>
                <th>Result</th>
                <th>Details</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <footer>
        <a href="index.html">&larr; Indexに戻る</a>
    </footer>

    <script>
    // ▼データ入力欄▼
    const csvData = `
abc439,2026-01-03T21:00:01.878889,"5完 (Perf:1339) [A:1:31, B:5:00, C:9:55, D:17:59, E:64:24 (WA3)]"
abc440,2026-01-10T21:00:02.012450,"4完 (Perf:1085) [A:1:32, B:3:04, C:94:28, D:59:47 (WA2)]"
arc212,2026-01-11T21:00:02.555304,"1完 (Perf:1089) [B:101:47]"
    `;

    // --- 設定: 境界線と比率 ---
    const SPLIT_TIME = 10;      // ここまで対数（分）
    const MAX_TIME = 120;       // コンテスト終了時間（分）
    const SPLIT_POS = 20.0;    // 画面上の境界位置（％）

    // --- 座標変換関数 ---
    function timeToVisual(t) {
        if (t <= 0) return 0;
        const minLogTime = 0.5; 
        if (t <= SPLIT_TIME) {
            const safeT = Math.max(t, minLogTime);
            const logMin = Math.log10(minLogTime);
            const logMax = Math.log10(SPLIT_TIME);
            const logT = Math.log10(safeT);
            const ratio = (logT - logMin) / (logMax - logMin);
            return ratio * SPLIT_POS;
        } else {
            const ratio = (t - SPLIT_TIME) / (MAX_TIME - SPLIT_TIME);
            return SPLIT_POS + (ratio * (100 - SPLIT_POS));
        }
    }

    // --- データ処理 ---
    const lines = csvData.trim().split('\n').filter(line => line.trim() !== "");
    const parsedData = lines.map(line => {
        const match = line.match(/^([^,]+),([^,]+),"(.+)"$/);
        if (!match) return null;

        const contest = match[1].toUpperCase();
        const dateDisplay = match[2].split('T')[0];
        const dateObj = new Date(match[2]); 
        const fullDetail = match[3];
        const contestType = contest.startsWith("ARC") ? "ARC" : "ABC";

        const problems = [];
        const problemMatches = fullDetail.matchAll(/([A-Z]):(\d+):(\d+)/g);
        for (const m of problemMatches) {
            problems.push({ 
                probName: m[1], 
                minutes: parseInt(m[2]) + parseInt(m[3]) / 60,
                visualX: timeToVisual(parseInt(m[2]) + parseInt(m[3]) / 60),
                label: `${m[2]}:${m[3]}`
            });
        }
        return { contest, contestType, dateDisplay, dateObj, fullDetail, problems };
    }).filter(item => item !== null);

    // ★重要: データ自体を「最新順（降順）」にソートします
    // これでテーブルもグラフも「リストの先頭＝最新」になります
    parsedData.sort((a, b) => b.dateObj - a.dateObj);

    // --- テーブル描画 ---
    function getPerfClass(perf) {
        if (perf < 400) return 'perf-gray';
        if (perf < 800) return 'perf-brown';
        if (perf < 1200) return 'perf-green';
        if (perf < 1600) return 'perf-cyan';
        if (perf < 2000) return 'perf-blue';
        if (perf < 2400) return 'perf-yellow';
        if (perf < 2800) return 'perf-orange';
        return 'perf-red';
    }

    const tableBody = document.querySelector("#log-table tbody");
    // parsedDataは既に最新順なので、そのままループ
    parsedData.forEach(item => {
        const perfMatch = item.fullDetail.match(/Perf:(\d+)/);
        const perf = perfMatch ? parseInt(perfMatch[1]) : 0;
        const solvedMatch = item.fullDetail.match(/(\d+)完/);
        const solved = solvedMatch ? solvedMatch[1] : "-";
        const detailTextMatch = item.fullDetail.match(/\[(.*)\]/);
        const detailText = detailTextMatch ? detailTextMatch[1] : item.fullDetail;

        const tr = document.createElement("tr");
        tr.innerHTML = `
            <td class="date-cell">${item.dateDisplay}</td>
            <td><a href="https://atcoder.jp/contests/${item.contest.toLowerCase()}" target="_blank" style="text-decoration:none; color:#333; font-weight:bold;">${item.contest}</a></td>
            <td>${solved}完 <span class="${getPerfClass(perf)}">Perf:${perf}</span></td>
            <td class="details">${detailText}</td>
        `;
        tableBody.appendChild(tr);
    });

    // --- グラフ描画 (Chart.js) ---
    const ctx = document.getElementById('timelineChart').getContext('2d');
    
    // ラベル配列も「最新順」で作成
    const yLabels = parsedData.map(d => `${d.contest} (${d.dateDisplay.slice(5)})`);

    // ABC用スタイル
    const problemStylesABC = {
        'A': { bg: '#ffffff', border: '#888888' },
        'B': { bg: '#808080', border: '#808080' },
        'C': { bg: '#804000', border: '#804000' },
        'D': { bg: '#008000', border: '#008000' },
        'E': { bg: '#00C0C0', border: '#00C0C0' },
        'F': { bg: '#0000FF', border: '#0000FF' },
        'G': { bg: '#C0C000', border: '#C0C000' },
        'H': { bg: '#FF8000', border: '#FF8000' }
    };
    // ARC用スタイル
    const problemStylesARC = {
        'A': { bg: '#804000', border: '#804000' },
        'B': { bg: '#008000', border: '#008000' },
        'C': { bg: '#00C0C0', border: '#00C0C0' },
        'D': { bg: '#0000FF', border: '#0000FF' },
        'E': { bg: '#C0C000', border: '#C0C000' },
        'F': { bg: '#FF8000', border: '#FF8000' }
    };

    const datasetLabels = ['A','B','C','D','E','F','G','H'];
    const datasets = datasetLabels.map(p => {
        return {
            label: `Problem ${p}`,
            data: [],
            backgroundColor: problemStylesABC[p] ? problemStylesABC[p].bg : '#000',
            borderColor: problemStylesABC[p] ? problemStylesABC[p].border : '#000',
            borderWidth: 1,
            pointRadius: 6,
            pointHoverRadius: 8
        };
    });

    parsedData.forEach((row, index) => {
        row.problems.forEach(p => {
            const datasetIndex = datasets.findIndex(ds => ds.label === `Problem ${p.probName}`);
            if (datasetIndex !== -1) {
                datasets[datasetIndex].data.push({
                    x: p.visualX,
                    y: yLabels[index], // 最新順のラベル
                    originalTime: p.label,
                    contestType: row.contestType
                });
            }
        });
    });

    function resolveColor(context, type) {
        const raw = context.raw;
        if (!raw) return undefined;
        
        const pLabel = context.dataset.label.split(' ')[1];
        const cType = raw.contestType || "ABC";
        
        let style;
        if (cType === "ARC") {
            style = problemStylesARC[pLabel] || { bg: '#000', border: '#000' };
        } else {
            style = problemStylesABC[pLabel] || { bg: '#000', border: '#000' };
        }
        return type === 'bg' ? style.bg : style.border;
    }

    const targetTicksTime = [0.5, 1, 2, 5, 10, 20, 30, 45, 60, 80, 100];
    const targetTicksVisual = targetTicksTime.map(t => ({ 
        val: timeToVisual(t), 
        label: t === 0.5 ? 'Start' : t.toString() 
    }));

    new Chart(ctx, {
        type: 'scatter',
        data: {
            labels: yLabels, // これで軸の順序を明示
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    title: { display: true, text: '経過時間 (分)' },
                    min: 0,
                    max: 100,
                    afterBuildTicks: function(axis) {
                        axis.ticks = targetTicksVisual.map(t => ({value: t.val}));
                    },
                    ticks: {
                        callback: function(value, index) {
                            const match = targetTicksVisual.find(t => Math.abs(t.val - value) < 1);
                            return match ? match.label : '';
                        }
                    },
                    grid: {
                        lineWidth: function(context) {
                            if (Math.abs(context.tick.value - SPLIT_POS) < 1) return 2;
                            return 1;
                        }
                    }
                },
                y: {
                    type: 'category',
                    offset: true,
                    // ★重要: reverse: true を設定
                    // これにより、配列の0番目（最新）がグラフの「上」に来ます
                    reverse: true,
                    grid: { color: '#f0f0f0' }
                }
            },
            elements: {
                point: {
                    backgroundColor: function(context) { return resolveColor(context, 'bg'); },
                    borderColor: function(context) { return resolveColor(context, 'border'); }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw.originalTime}`;
                        }
                    }
                },
                legend: {
                    position: 'bottom',
                    labels: { 
                        boxWidth: 10, 
                        padding: 20,
                        generateLabels: function(chart) {
                            const defaults = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                            return defaults.map(label => label);
                        }
                    }
                }
            }
        }
    });
    </script>

</body>
</html>
